import { existsSync, readFileSync, writeFileSync } from 'fs';
import { resolve } from 'path';

// Constants
const AUTO_GENERATED_MARKERS = {
	START: '// =============================================================================',
	HEADER: '// AUTO-GENERATED CODE BY SVELTEKIT-TRANSLATIONS-LOADER PLUGIN',
	END: '// END AUTO-GENERATED CODE'
} as const;

const AUTO_GENERATED_PATTERNS = [
	'const _translationKeys',
	'// Auto-injected translation keys',
	'import { _getTranslations }',
	'eslint-disable-next-line',
	'@typescript-eslint/no-explicit-any',
	'keyof typeof import',
	'> = ['
] as const;

// Types
interface ParsedFileContent {
	imports: string[];
	customCode: string[];
	hasLoadFunction: boolean;
	loadFunctionStart: number;
	loadFunctionEnd: number;
	existingReturnContent: string;
}

interface LoadFunctionConfig {
	loadType: string;
	existingReturnContent: string;
}

/**
 * Check if a line contains auto-generated content
 */
function isAutoGeneratedLine(line: string): boolean {
	return (
		AUTO_GENERATED_PATTERNS.some((pattern) => line.includes(pattern)) ||
		(line.trim().startsWith("'") && line.trim().endsWith("',")) ||
		(line.trim().startsWith("'") && line.trim().endsWith("'")) ||
		line.trim() === '];' ||
		line.trim() === ']'
	);
}

/**
 * Check if a line is an auto-generated section marker
 */
function isAutoGeneratedMarker(line: string): boolean {
	return Object.values(AUTO_GENERATED_MARKERS).some((marker) => line.includes(marker));
}

/**
 * Clean and format existing return content
 */
function cleanReturnContent(content: string): string {
	return content
		.split('\n')
		.map((line) => line.trim())
		.filter((line) => line.length > 0 && !line.includes('_loadedTranslations'))
		.map((line) => line.replace(/,$/, ''))
		.join(', ');
}

/**
 * Extract existing return content from load function code
 */
function extractReturnContent(loadFunctionCode: string): string {
	const returnMatch = loadFunctionCode.match(/return\s*\{([^}]*)\}/);
	if (!returnMatch) return '';

	return cleanReturnContent(returnMatch[1]);
}

/**
 * Parse existing file content to extract imports, custom code, and load function info
 */
function parseFileContent(existingContent: string): ParsedFileContent {
	const lines = existingContent.split('\n');
	const imports: string[] = [];
	const customCode: string[] = [];
	let inLoadFunction = false;
	let braceCount = 0;
	let hasLoadFunction = false;
	let loadFunctionStart = -1;
	let loadFunctionEnd = -1;
	let inAutoGenerated = false;
	let existingReturnContent = '';

	for (let i = 0; i < lines.length; i++) {
		const line = lines[i];

		// Handle auto-generated section markers
		if (isAutoGeneratedMarker(line)) {
			inAutoGenerated = true;
			continue;
		}

		// Skip auto-generated content
		if (inAutoGenerated) {
			if (line.trim() === '' || (!line.includes('//') && line.trim() !== '')) {
				inAutoGenerated = false;
			} else {
				continue;
			}
		}

		// Skip auto-generated patterns
		if (isAutoGeneratedLine(line)) {
			continue;
		}

		// Detect load function
		if (
			(line.includes('export const load:') || line.includes('export const load =')) &&
			!inLoadFunction
		) {
			hasLoadFunction = true;
			loadFunctionStart = i;
			inLoadFunction = true;
			braceCount = 0;
		}

		if (inLoadFunction) {
			braceCount += (line.match(/\{/g) || []).length;
			braceCount -= (line.match(/\}/g) || []).length;

			if (braceCount === 0 && line.trim() !== '') {
				loadFunctionEnd = i;
				inLoadFunction = false;

				// Extract return content from load function
				const loadLines = lines.slice(loadFunctionStart, loadFunctionEnd + 1);
				const loadFunctionCode = loadLines.join('\n');
				existingReturnContent = extractReturnContent(loadFunctionCode);
			}
		} else {
			// Collect imports and custom code
			if (line.trim().startsWith('import ')) {
				imports.push(line);
			} else if (line.trim() !== '') {
				customCode.push(line);
			}
		}
	}

	return {
		imports,
		customCode,
		hasLoadFunction,
		loadFunctionStart,
		loadFunctionEnd,
		existingReturnContent
	};
}

/**
 * Generate the auto-generated code block with proper import path
 */
function generateTranslationsCode(keysArray: string[]): string {
	return `${AUTO_GENERATED_MARKERS.START}
${AUTO_GENERATED_MARKERS.HEADER}
import { _getTranslations } from 'sveltekit-translations-loader/server';
const _translationKeys: string[] = [${keysArray.map((key) => `'${key}'`).join(', ')}];
${AUTO_GENERATED_MARKERS.END}
${AUTO_GENERATED_MARKERS.START}
`;
}

/**
 * Create load function code
 */
function createLoadFunction(config: LoadFunctionConfig): string {
	const { loadType, existingReturnContent } = config;
	const returnContent = existingReturnContent
		? `${existingReturnContent},\n\t\t_loadedTranslations: _getTranslations(_translationKeys)`
		: `_loadedTranslations: _getTranslations(_translationKeys)`;

	return `export const load: ${loadType} = async () => {
	return {
		${returnContent}
	};
}`;
}

/**
 * Get Prettier configuration
 */
async function getPrettierConfig(): Promise<Record<string, unknown>> {
	try {
		const configPath = resolve(process.cwd(), '.prettierrc');
		if (existsSync(configPath)) {
			const configContent = readFileSync(configPath, 'utf8');
			return JSON.parse(configContent);
		}
	} catch {
		console.log('‚ÑπÔ∏è  Could not read Prettier config, using defaults');
	}

	return {};
}

/**
 * Format a file using Prettier (optional)
 */
async function formatFile(filePath: string, content: string): Promise<string> {
	try {
		const prettier = await import('prettier').catch(() => null);
		if (!prettier) {
			console.log('‚ÑπÔ∏è  Prettier not available, writing file without formatting');
			return content;
		}

		const prettierConfig = await getPrettierConfig();

		const formattedContent = await prettier.format(content, {
			filepath: filePath,
			parser: 'typescript',
			...prettierConfig,
			// Fallback defaults
			semi: (prettierConfig.semi as boolean) ?? true,
			singleQuote: (prettierConfig.singleQuote as boolean) ?? true,
			tabWidth: (prettierConfig.tabWidth as number) ?? 2,
			useTabs: (prettierConfig.useTabs as boolean) ?? true,
			trailingComma: (prettierConfig.trailingComma as 'none' | 'es5' | 'all') ?? 'none',
			printWidth: (prettierConfig.printWidth as number) ?? 100
		});

		return formattedContent;
	} catch (error) {
		console.log(
			`‚ÑπÔ∏è  Prettier formatting failed for ${filePath}, writing file without formatting:`,
			error
		);
		return content;
	}
}

/**
 * Build final file content
 */
function buildFileContent(
	parsedContent: ParsedFileContent,
	requiredImports: string[],
	generatedCode: string,
	loadFunctionConfig: LoadFunctionConfig
): string {
	const { imports, customCode } = parsedContent;

	// Merge and filter imports
	const allImports = [...new Set([...imports, ...requiredImports])];
	const filteredImports = allImports.filter(
		(importLine) => !importLine.includes('_getTranslations')
	);

	// Clean up custom code
	const cleanCustomCode = customCode
		.join('\n')
		.replace(/\n\s*\n\s*\n/g, '\n\n')
		.trim();

	// Build content
	let finalContent = filteredImports.join('\n');
	finalContent += '\n' + generatedCode;

	if (cleanCustomCode) {
		finalContent += '\n\n' + cleanCustomCode;
	}

	// Add load function
	const loadFunction = createLoadFunction(loadFunctionConfig);
	finalContent += '\n\n' + loadFunction;

	return finalContent;
}

/**
 * Helper function to modify existing load function to add _loadedTranslations
 */
export function modifyLoadFunction(loadFunctionCode: string): string {
	const hasLoadedTranslations = loadFunctionCode.includes('_loadedTranslations');

	if (hasLoadedTranslations) {
		return loadFunctionCode.replace(
			/_loadedTranslations:\s*_getTranslations\(\)/g,
			'_loadedTranslations: _getTranslations(_translationKeys)'
		);
	}

	const lines = loadFunctionCode.split('\n');
	const functionSignature = lines.find((line) => line.includes('export const load'));
	const existingContent = extractReturnContent(loadFunctionCode);

	return `${functionSignature}
	return {
		${existingContent ? `${existingContent},\n\t\t` : ''}_loadedTranslations: _getTranslations(_translationKeys)
	};
}`;
}

/**
 * Inject translation keys into load function with support for nested routes and accumulated keys
 */
export function injectTranslationKeys(
	serverFilePath: string,
	usedKeys: Set<string>,
	routePath: string,
	defaultPath: string,
	verbose: boolean = false
): void {
	if (verbose) {
		console.log(`üîß injectTranslationKeys called for: ${serverFilePath}`);
	}

	const keysArray = Array.from(usedKeys);
	const isLayoutFile = serverFilePath.includes('+layout.server.ts');
	const loadType = isLayoutFile ? 'LayoutServerLoad' : 'PageServerLoad';
	const requiredImports = [`import type { ${loadType} } from './$types.js';`];
	const generatedCode = generateTranslationsCode(keysArray);

	let finalContent: string;

	if (existsSync(serverFilePath)) {
		if (verbose) {
			console.log(`üìÅ File exists: ${serverFilePath}`);
		}

		const existingContent = readFileSync(serverFilePath, 'utf8');
		const parsedContent = parseFileContent(existingContent);

		const loadFunctionConfig: LoadFunctionConfig = {
			loadType,
			existingReturnContent: parsedContent.existingReturnContent
		};

		finalContent = buildFileContent(
			parsedContent,
			requiredImports,
			generatedCode,
			loadFunctionConfig
		);
	} else {
		// Create new file
		const loadFunctionConfig: LoadFunctionConfig = {
			loadType,
			existingReturnContent: ''
		};

		finalContent =
			requiredImports.join('\n') +
			'\n' +
			generatedCode +
			'\n\n' +
			createLoadFunction(loadFunctionConfig);
	}

	// Write file with formatting
	formatFile(serverFilePath, finalContent)
		.then((formattedContent) => {
			writeFileSync(serverFilePath, formattedContent, 'utf8');
		})
		.catch((error) => {
			console.warn(`‚ö†Ô∏è  Failed to format ${serverFilePath}:`, error);
			writeFileSync(serverFilePath, finalContent, 'utf8');
		});

	if (verbose) {
		const fileType = isLayoutFile ? '+layout.server.ts' : '+page.server.ts';
		const action = existsSync(serverFilePath) ? 'Updated' : 'Created';
		console.log(
			`‚úÖ ${action} ${fileType} for route ${routePath} with ${keysArray.length} translation keys`
		);
	}
}
