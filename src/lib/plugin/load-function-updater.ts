import { existsSync, readFileSync } from 'fs';
import { resolve } from 'path';
import { queueFileWrite } from './batch-file-writer.js';
import { hasContentChanged } from './shared-utils.js';

// Constants
const AUTO_GENERATED_MARKERS = {
	START: '// =============================================================================',
	HEADER: '// AUTO-GENERATED CODE BY SVELTEKIT-TRANSLATIONS-LOADER PLUGIN',
	END: '// END AUTO-GENERATED CODE'
} as const;

interface LoadFunctionConfig {
	loadType: string;
	existingReturnContent: string;
}

/**
 * Clean and format existing return content
 */
function cleanReturnContent(content: string): string {
	return content
		.split('\n')
		.map((line) => line.trim())
		.filter((line) => line.length > 0 && !line.includes('_loadedTranslations'))
		.map((line) => line.replace(/,$/, ''))
		.join(', ');
}

/**
 * Extract existing return content from load function code with support for complex patterns
 */
function extractReturnContent(loadFunctionCode: string): string {
	// Handle multiple return statements and complex logic
	const lines = loadFunctionCode.split('\n');
	let inReturnBlock = false;
	let braceCount = 0;
	const returnContent: string[] = [];
	let foundReturn = false;

	for (const line of lines) {
		const trimmedLine = line.trim();

		// Check for return statement start
		if (trimmedLine.startsWith('return') && !foundReturn) {
			foundReturn = true;
			inReturnBlock = true;
			braceCount = 0;

			// Handle inline return: return { prop: value };
			const inlineMatch = trimmedLine.match(/return\s*\{([^}]*)\}/);
			if (inlineMatch) {
				return cleanReturnContent(inlineMatch[1]);
			}

			// Handle multi-line return: return { ... }
			const openBraceMatch = trimmedLine.match(/return\s*\{/);
			if (openBraceMatch) {
				braceCount = 1;
				continue;
			}
		}

		if (inReturnBlock) {
			// Count braces to find the end of the return object
			braceCount += (line.match(/\{/g) || []).length;
			braceCount -= (line.match(/\}/g) || []).length;

			if (braceCount > 0) {
				// We're inside the return object
				returnContent.push(line);
			} else if (braceCount === 0) {
				// End of return object - don't include the closing brace line
				break;
			}
		}
	}

	if (returnContent.length > 0) {
		const fullReturnContent = returnContent.join('\n');
		// Extract content between the outermost braces, excluding the braces themselves
		const match = fullReturnContent.match(/\{([\s\S]*)/);
		if (match) {
			return cleanReturnContent(match[1]);
		}
	}

	return '';
}

/**
 * Remove auto-generated code block from content
 */
function removeAutoGeneratedCode(content: string): string {
	const autoGeneratedStart = content.indexOf(AUTO_GENERATED_MARKERS.START);
	const autoGeneratedEnd = content.indexOf(AUTO_GENERATED_MARKERS.END);

	if (autoGeneratedStart !== -1 && autoGeneratedEnd !== -1) {
		// Remove existing auto-generated code block and any duplicate markers
		const beforeBlock = content.substring(0, autoGeneratedStart);
		const afterBlock = content.substring(autoGeneratedEnd + AUTO_GENERATED_MARKERS.END.length);

		// Clean up any duplicate markers in the after block
		const cleanedAfterBlock = afterBlock.replace(
			new RegExp(`\\s*${AUTO_GENERATED_MARKERS.START}\\s*`, 'g'),
			''
		);

		return beforeBlock + cleanedAfterBlock;
	}

	return content;
}

/**
 * Generate the auto-generated code block with proper import path
 */
function generateTranslationsCode(): { code: string; functionId: string } {
	const importPath = '$lib/.translations/_generated/server/translations-injector';
	const functionId = Math.random().toString(36).substring(2, 15);

	const code = `${AUTO_GENERATED_MARKERS.START}
${AUTO_GENERATED_MARKERS.HEADER}
import { _getTranslations } from '${importPath}';
const _functionId = '${functionId}';
${AUTO_GENERATED_MARKERS.END}
`;

	return { code, functionId };
}

/**
 * Create load function code
 */
function createLoadFunction(config: LoadFunctionConfig): string {
	const { existingReturnContent } = config;
	const returnContent = existingReturnContent
		? `${existingReturnContent},\n\t\t_loadedTranslations: _getTranslations( _functionId)`
		: `_loadedTranslations: _getTranslations( _functionId)`;

	return `export const load = async () => {
	return {
		${returnContent}
	};
}`;
}

/**
 * Get Prettier configuration
 */
async function getPrettierConfig(): Promise<Record<string, unknown>> {
	try {
		const configPath = resolve(process.cwd(), '.prettierrc');
		if (existsSync(configPath)) {
			const configContent = readFileSync(configPath, 'utf8');
			return JSON.parse(configContent);
		}
	} catch {
		console.log('‚ÑπÔ∏è  Could not read Prettier config, using defaults');
	}

	return {};
}

/**
 * Format a file using Prettier (optional)
 */
async function formatFile(filePath: string, content: string): Promise<string> {
	try {
		const prettier = await import('prettier').catch(() => null);
		if (!prettier) {
			console.log('‚ÑπÔ∏è  Prettier not available, writing file without formatting');
			return content;
		}

		const prettierConfig = await getPrettierConfig();

		const formattedContent = await prettier.format(content, {
			filepath: filePath,
			parser: 'typescript',
			...prettierConfig,
			// Fallback defaults
			semi: (prettierConfig.semi as boolean) ?? true,
			singleQuote: (prettierConfig.singleQuote as boolean) ?? true,
			tabWidth: (prettierConfig.tabWidth as number) ?? 2,
			useTabs: (prettierConfig.useTabs as boolean) ?? true,
			trailingComma: (prettierConfig.trailingComma as 'none' | 'es5' | 'all') ?? 'none',
			printWidth: (prettierConfig.printWidth as number) ?? 100
		});

		return formattedContent;
	} catch (error) {
		console.log(
			`‚ÑπÔ∏è  Prettier formatting failed for ${filePath}, writing file without formatting:`,
			error
		);
		return content;
	}
}

/**
 * Build final file content
 */
function buildFileContent(
	parsedContent: { imports: string[]; customCode: string[] },
	requiredImports: string[],
	generatedCode: { code: string; functionId: string },
	loadFunctionConfig: LoadFunctionConfig
): string {
	console.log('üöÄ ~ buildFileContent ~ generatedCode:', generatedCode);
	const { imports, customCode } = parsedContent;

	// Merge and filter imports
	const allImports = [...new Set([...imports, ...requiredImports])];
	const filteredImports = allImports.filter(
		(importLine) => !importLine.includes('_getTranslations')
	);

	// Clean up custom code
	const cleanCustomCode = customCode
		.join('\n')
		.replace(/\n\s*\n\s*\n/g, '\n\n')
		.trim();

	// Build content
	let finalContent = filteredImports.join('\n');
	finalContent += '\n' + generatedCode.code;

	if (cleanCustomCode) {
		finalContent += '\n\n' + cleanCustomCode;
	}

	// Add load function
	const loadFunction = createLoadFunction(loadFunctionConfig);
	finalContent += '\n\n' + loadFunction;

	return finalContent;
}

/**
 * Helper function to modify existing load function to add _loadedTranslations
 */
export function modifyLoadFunction(loadFunctionCode: string): string {
	const hasLoadedTranslations = loadFunctionCode.includes('_loadedTranslations');

	if (hasLoadedTranslations) {
		// Replace any existing _loadedTranslations calls with the new _fileType parameter
		return loadFunctionCode.replace(
			/_loadedTranslations:\s*_getTranslations\([^)]*\)/g,
			'_loadedTranslations: _getTranslations( _functionId)'
		);
	}

	const lines = loadFunctionCode.split('\n');
	const functionSignature = lines.find((line) => line.includes('export const load'));
	const existingContent = extractReturnContent(loadFunctionCode);

	return `${functionSignature}
	return {
		${existingContent ? `${existingContent},\n\t\t` : ''}_loadedTranslations: _getTranslations( _functionId)
	};
}`;
}

/**
 * Simple function to inject _loadedTranslations into an existing load function
 * Returns { success: boolean, code: string, warning?: string }
 */
function injectLoadedTranslations(loadFunctionCode: string): {
	success: boolean;
	code: string;
	warning?: string;
} {
	// Always process the file to ensure existing _translationKeys calls get replaced with _fileType

	// Check if _getTranslations and _fileType are available
	if (!loadFunctionCode.includes('_getTranslations') || !loadFunctionCode.includes('_fileType')) {
		return {
			success: false,
			code: loadFunctionCode,
			warning:
				'‚ö†Ô∏è  Could not inject _loadedTranslations: missing _getTranslations or _fileType imports'
		};
	}

	// Check if _loadedTranslations already exists
	const hasExistingLoadedTranslations = loadFunctionCode.includes('_loadedTranslations');

	// If _loadedTranslations already exists, clean up duplicates and replace parameters
	if (hasExistingLoadedTranslations) {
		// First, remove all duplicate _loadedTranslations lines, keeping only one
		let processedCode = loadFunctionCode.replace(
			/(_loadedTranslations:\s*_getTranslations\([^)]*\)\s*,?\s*\n\s*)+/g,
			'_loadedTranslations: _getTranslations( _functionId),\n\t\t'
		);

		// Then replace any remaining _loadedTranslations calls with the new _fileType parameter
		processedCode = processedCode.replace(
			/_loadedTranslations:\s*_getTranslations\([^)]*\)/g,
			'_loadedTranslations: _getTranslations( _functionId)'
		);

		// Clean up any trailing commas
		processedCode = processedCode.replace(/,\s*}/g, '}');

		return { success: true, code: processedCode };
	}

	// Split the code into lines to process load functions specifically
	const lines = loadFunctionCode.split('\n');
	let inLoadFunction = false;
	let inReturnBlock = false;
	let braceCount = 0;
	let foundLoadFunction = false;
	let foundReturnStatement = false;
	const modifiedLines: string[] = [];

	for (let i = 0; i < lines.length; i++) {
		const line = lines[i];
		const trimmedLine = line.trim();

		// Check if we're entering a load function
		if (trimmedLine.startsWith('export const load') && trimmedLine.includes('async')) {
			inLoadFunction = true;
			foundLoadFunction = true;
			modifiedLines.push(line);
			continue;
		}

		// Check if we're exiting a load function
		if (inLoadFunction && trimmedLine === '}' && !inReturnBlock) {
			// Only exit if we're not inside a nested block
			// We need to count braces to determine if this is the end of the load function
			let braceCount = 0;
			let foundLoadFunctionStart = false;

			// Look backwards to find the start of the load function
			for (let j = i; j >= 0; j--) {
				const prevLine = lines[j].trim();
				if (prevLine.startsWith('export const load') && prevLine.includes('async')) {
					foundLoadFunctionStart = true;
					break;
				}
				if (prevLine === '{') {
					braceCount++;
				} else if (prevLine === '}') {
					braceCount--;
				}
			}

			// Only exit if we've found the load function start and brace count is balanced
			if (foundLoadFunctionStart && braceCount === 0) {
				inLoadFunction = false;
				modifiedLines.push(line);
				continue;
			}
		}

		// If we're inside a load function and this is a return statement
		if (
			inLoadFunction &&
			(trimmedLine.startsWith('return {') ||
				trimmedLine === 'return {' ||
				trimmedLine === 'return' ||
				trimmedLine.includes('return {'))
		) {
			inReturnBlock = true;
			foundReturnStatement = true;
			braceCount = 0;

			// Check if the return object is empty
			if (trimmedLine.includes('return {}') || trimmedLine.includes('return { }')) {
				modifiedLines.push(
					line.replace(
						/return\s*\{\s*\}/,
						'return { _loadedTranslations: _getTranslations( _functionId) }'
					)
				);
				inReturnBlock = false;
			} else {
				// For multi-line return statements, we need to find the closing brace
				braceCount += (line.match(/\{/g) || []).length;
				braceCount -= (line.match(/\}/g) || []).length;

				// Look ahead to find the closing brace
				let j = i + 1;
				const returnStatementLines = [line];

				while (j < lines.length && braceCount > 0) {
					const nextLine = lines[j];
					returnStatementLines.push(nextLine);
					braceCount += (nextLine.match(/\{/g) || []).length;
					braceCount -= (nextLine.match(/\}/g) || []).length;
					j++;
				}

				// Safety check: ensure we found a complete return statement
				if (braceCount !== 0) {
					return {
						success: false,
						code: loadFunctionCode,
						warning:
							'‚ö†Ô∏è  Could not inject _loadedTranslations: incomplete return statement (unmatched braces)'
					};
				}

				// Process the return statement
				const returnStatement = returnStatementLines.join('\n');

				// Find the last property line before the closing brace
				// We need to work with the original lines to preserve indentation
				let lastPropertyIndex = -1;
				let lastPropertyOriginalLine = '';

				for (let k = returnStatementLines.length - 1; k >= 0; k--) {
					const originalLine = returnStatementLines[k];
					const trimmedLine = originalLine.trim();
					if (trimmedLine && !trimmedLine.startsWith('}') && !trimmedLine.startsWith('return')) {
						lastPropertyIndex = k;
						lastPropertyOriginalLine = originalLine;
						break;
					}
				}

				if (lastPropertyIndex >= 0) {
					// Check if the last property ends with a comma
					const hasComma = lastPropertyOriginalLine.trim().endsWith(',');

					// Determine the indentation level from the last property
					const indentation = lastPropertyOriginalLine.match(/^\s*/)?.[0] || '\t\t';

					if (hasComma) {
						// Insert _loadedTranslations after the last property
						const modifiedReturnStatement = returnStatement.replace(
							lastPropertyOriginalLine,
							lastPropertyOriginalLine +
								'\n' +
								indentation +
								'_loadedTranslations: _getTranslations( _functionId)'
						);
						modifiedLines.push(modifiedReturnStatement);
					} else {
						// Add comma to last property and insert _loadedTranslations
						const modifiedReturnStatement = returnStatement.replace(
							lastPropertyOriginalLine,
							lastPropertyOriginalLine +
								',\n' +
								indentation +
								'_loadedTranslations: _getTranslations( _functionId)'
						);
						modifiedLines.push(modifiedReturnStatement);
					}
				} else {
					// No properties found, just add _loadedTranslations
					const modifiedReturnStatement = returnStatement.replace(
						/\{\s*\}/,
						'{ _loadedTranslations: _getTranslations( _functionId) }'
					);
					modifiedLines.push(modifiedReturnStatement);
				}

				// Skip the lines we've already processed
				i = j - 1;
				inReturnBlock = false;
			}
		} else if (inReturnBlock) {
			// We're inside a return block but not processing it (already handled above)
			continue;
		} else {
			modifiedLines.push(line);
		}
	}

	// Safety check: ensure we found both load function and return statement
	if (!foundLoadFunction) {
		return {
			success: false,
			code: loadFunctionCode,
			warning: '‚ö†Ô∏è  Could not inject _loadedTranslations: no load function found'
		};
	}

	if (!foundReturnStatement) {
		return {
			success: false,
			code: loadFunctionCode,
			warning:
				'‚ö†Ô∏è  Could not inject _loadedTranslations: no return statement found in load function'
		};
	}

	return { success: true, code: modifiedLines.join('\n') };
}

/**
 * Inject translation keys into load function with support for nested routes and accumulated keys
 */
export function injectTranslationKeys(
	serverFilePath: string,
	usedKeys: Set<string>,
	routePath: string,
	verbose: boolean = false
): string | null {
	if (verbose) {
		console.log(`üîß injectTranslationKeys called for: ${serverFilePath}`);
	}

	const keysArray = Array.from(usedKeys);

	const generatedCodeResult = generateTranslationsCode();
	const functionId = generatedCodeResult.functionId;

	// If there are no keys and no existing file, skip entirely
	if (keysArray.length === 0 && !existsSync(serverFilePath)) {
		if (verbose) {
			console.log(
				`‚è≠Ô∏è  Skipping ${serverFilePath} for route ${routePath} - no keys and no existing file`
			);
		}
		return null;
	}

	let finalContent: string;

	if (existsSync(serverFilePath)) {
		if (verbose) {
			console.log(`üìÅ File exists: ${serverFilePath}`);
		}

		const existingContent = readFileSync(serverFilePath, 'utf8');

		// Check if load function already exists
		if (existingContent.includes('export const load')) {
			// Remove existing auto-generated code block if it exists
			let newContent = removeAutoGeneratedCode(existingContent);

			// Always add new auto-generated code block to ensure consistent structure
			// Find the first export statement to insert before
			const lines = newContent.split('\n');
			let insertIndex = 0;

			for (let i = 0; i < lines.length; i++) {
				const line = lines[i].trim();
				if (line.startsWith('export')) {
					insertIndex = i;
					break;
				}
			}

			// Insert the generated code before the first export statement
			const codeLines = generatedCodeResult.code.split('\n');
			lines.splice(insertIndex, 0, ...codeLines);
			newContent = lines.join('\n');

			// Always inject _loadedTranslations to ensure existing _translationKeys calls get replaced
			const injectionResult = injectLoadedTranslations(newContent);

			if (!injectionResult.success) {
				if (verbose) {
					console.warn(`‚ö†Ô∏è  ${injectionResult.warning}`);
				}
				// Use the original content if injection failed
				finalContent = injectionResult.code;
			} else {
				finalContent = injectionResult.code;
			}
		} else {
			// If there are no keys, don't create a new load function
			if (keysArray.length === 0) {
				if (verbose) {
					console.log(`‚è≠Ô∏è  Skipping load function creation for ${serverFilePath} - no keys`);
				}
				return null;
			}

			// Create new load function
			const loadFunctionConfig: LoadFunctionConfig = {
				loadType: '',
				existingReturnContent: ''
			};

			finalContent = buildFileContent(
				{ imports: [], customCode: [] },
				[],
				generatedCodeResult,
				loadFunctionConfig
			);
		}
	} else {
		// If there are no keys, don't create a new file
		if (keysArray.length === 0) {
			if (verbose) {
				console.log(`‚è≠Ô∏è  Skipping file creation for ${serverFilePath} - no keys`);
			}
			return null;
		}

		// Create new file
		const loadFunctionConfig: LoadFunctionConfig = {
			loadType: '',
			existingReturnContent: ''
		};

		finalContent = generatedCodeResult.code + '\n\n' + createLoadFunction(loadFunctionConfig);
	}

	// Check if content has actually changed before writing
	if (!hasContentChanged(serverFilePath, finalContent)) {
		if (verbose) {
			const fileType = serverFilePath.includes('+layout.server.ts')
				? '+layout.server.ts'
				: '+page.server.ts';
			console.log(`‚è≠Ô∏è  Skipping ${fileType} for route ${routePath} - no changes detected`);
		}
		return functionId;
	}

	// Write file with formatting
	formatFile(serverFilePath, finalContent)
		.then((formattedContent) => {
			queueFileWrite(serverFilePath, formattedContent, { encoding: 'utf8' });
		})
		.catch((error) => {
			console.warn(`‚ö†Ô∏è  Failed to format ${serverFilePath}:`, error);
			queueFileWrite(serverFilePath, finalContent, { encoding: 'utf8' });
		});

	if (verbose) {
		const fileType = serverFilePath.includes('+layout.server.ts')
			? '+layout.server.ts'
			: '+page.server.ts';
		const action = existsSync(serverFilePath) ? 'Updated' : 'Created';
		const keyCount = keysArray.length;
		const keyInfo = keyCount === 0 ? 'removed all keys' : `with ${keyCount} translation keys`;
		console.log(`‚úÖ ${action} ${fileType} for route ${routePath} ${keyInfo}`);
	}

	return functionId;
}
