import { existsSync, readFileSync, writeFileSync } from 'fs';

/**
 * Helper function to modify existing load function to add _loadedTranslations
 */
export function modifyLoadFunction(loadFunctionCode: string): string {
	// Find the return statement and add _loadedTranslations
	const returnMatch = loadFunctionCode.match(/return\s*\{([^}]*)\}/);

	if (returnMatch) {
		const returnContent = returnMatch[1];
		const hasLoadedTranslations = returnContent.includes('_loadedTranslations');

		if (!hasLoadedTranslations) {
			// Clean up the return content - remove extra whitespace and empty lines
			const cleanReturnContent = returnContent
				.split('\n')
				.map((line) => line.trim())
				.filter((line) => line.length > 0)
				.join(', ');

			// Add _loadedTranslations to the return statement
			const modifiedReturn = cleanReturnContent
				? `\n\t\t${cleanReturnContent},\n\t\t_loadedTranslations: _getTranslations()`
				: `\n\t\t_loadedTranslations: _getTranslations()`;

			return loadFunctionCode.replace(/return\s*\{([^}]*)\}/, `return {${modifiedReturn}\n\t}`);
		}
	} else {
		// If no return statement found, add one at the end of the function
		const hasLoadedTranslations = loadFunctionCode.includes('_loadedTranslations');
		if (!hasLoadedTranslations) {
			// Find the closing brace of the function and add return statement before it
			const lines = loadFunctionCode.split('\n');
			const newLines = [];
			let braceCount = 0;
			let inFunction = false;

			for (const line of lines) {
				if (line.includes('export const load') && !inFunction) {
					inFunction = true;
					braceCount = 0;
				}

				if (inFunction) {
					braceCount += (line.match(/\{/g) || []).length;
					braceCount -= (line.match(/\}/g) || []).length;

					// If we're about to close the function and haven't added return yet
					if (braceCount === 0 && line.trim() === '}') {
						newLines.push('\treturn {\n\t\t_loadedTranslations: _getTranslations()\n\t};');
					}
				}

				newLines.push(line);
			}

			return newLines.join('\n');
		}
	}

	return loadFunctionCode;
}

/**
 * Generate the auto-generated code block for translations
 */
export function generateTranslationsCode(keysArray: string[]): string {
	return `

// =============================================================================
// AUTO-GENERATED CODE BY SVELTEKIT-TRANSLATIONS-LOADER PLUGIN
// DO NOT EDIT MANUALLY - This section will be overwritten on each build
// =============================================================================

// Auto-generated sveltekit-translations-loader translations function
function _getTranslations() {
	const event = getRequestEvent();
	const locale = event?.locals.locale || 'en-US';
	
	const allTranslations = translationsManager.getTranslations(locale);
	
	// Get accumulated translations from parent routes
	const parentTranslations = event?.locals._translationsData || {};
	
	// Auto-injected translation keys based on usage
	const currentTranslations = {
${keysArray.map((key) => `		'${key}': allTranslations['${key}'] || '${key} (missing)'`).join(',\n')}
	};
	
	// Merge with parent translations and extra keys
	const extraKeys = event?.locals.extraKeys || {};
	const combinedTranslations = { ...parentTranslations, ...currentTranslations, ...extraKeys };
	event.locals._translationsData = combinedTranslations;
	
	return combinedTranslations;
}

// =============================================================================
// END AUTO-GENERATED CODE
// =============================================================================
`;
}

/**
 * Inject translation keys into load function with support for nested routes and accumulated keys
 */
export function injectTranslationKeys(
	serverFilePath: string,
	usedKeys: Set<string>,
	routePath: string
): void {
	console.log(`üîß injectTranslationKeys called for: ${serverFilePath}`);
	const keysArray = Array.from(usedKeys);
	const isLayoutFile = serverFilePath.includes('+layout.server.ts');
	const loadType = isLayoutFile ? 'LayoutServerLoad' : 'PageServerLoad';

	// Required imports for the plugin
	const requiredImports = [
		`import type { ${loadType} } from './$types.js';`,
		`import { getRequestEvent } from '$app/server';`,
		`import { translationsManager } from '$lib/server/translations-manager.js';`
	];

	// Generate the auto-generated code block
	const generatedCode = generateTranslationsCode(keysArray);

	// Check if file exists and read existing content
	let finalContent = '';
	if (existsSync(serverFilePath)) {
		console.log(`üìÅ File exists: ${serverFilePath}`);
		const existingContent = readFileSync(serverFilePath, 'utf8');

		// Check if file already contains auto-generated section
		const autoGeneratedStart =
			'// =============================================================================\n// AUTO-GENERATED CODE BY SVELTEKIT-TRANSLATIONS-LOADER PLUGIN';
		const autoGeneratedEnd =
			'// =============================================================================\n// END AUTO-GENERATED CODE\n// =============================================================================';

		console.log(`üîç Checking for auto-generated section in ${serverFilePath}`);

		let existingImports: string[] = [];
		let existingCode = '';
		let hasLoadFunction = false;
		let loadFunctionStart = -1;
		let loadFunctionEnd = -1;

		if (existingContent.includes(autoGeneratedStart)) {
			console.log(`‚úÖ Found auto-generated section, replacing it`);
			// Split content into parts
			const parts = existingContent.split(autoGeneratedStart);
			const beforeAutoGenerated = parts[0];
			const afterAutoGenerated = existingContent.split(autoGeneratedEnd).slice(-1)[0];

			// Parse existing content before auto-generated section
			const lines = beforeAutoGenerated.split('\n');
			const importLines: string[] = [];
			const codeLines: string[] = [];
			let inLoadFunction = false;
			let braceCount = 0;

			for (let i = 0; i < lines.length; i++) {
				const line = lines[i];

				// Check if this line starts a load function (both with and without type annotation)
				if (
					(line.includes('export const load:') || line.includes('export const load =')) &&
					!inLoadFunction
				) {
					hasLoadFunction = true;
					loadFunctionStart = i;
					inLoadFunction = true;
					braceCount = 0;
				}

				if (inLoadFunction) {
					// Count braces to find the end of the load function
					braceCount += (line.match(/\{/g) || []).length;
					braceCount -= (line.match(/\}/g) || []).length;

					if (braceCount === 0 && line.trim() !== '') {
						loadFunctionEnd = i;
						inLoadFunction = false;
					}
				} else {
					// Check if this is an import statement
					if (line.trim().startsWith('import ')) {
						importLines.push(line);
					} else {
						codeLines.push(line);
					}
				}
			}

			existingImports = importLines;
			existingCode = codeLines.join('\n');

			// Add required imports if they don't exist
			const allImports = [...new Set([...existingImports, ...requiredImports])];

			// Build final content - clean up empty lines
			const cleanImports = allImports.join('\n');
			const cleanExistingCode = existingCode.replace(/\n\s*\n\s*\n/g, '\n\n').trim();

			finalContent = cleanImports;
			if (cleanExistingCode) {
				finalContent += '\n\n' + cleanExistingCode;
			}

			if (hasLoadFunction) {
				// Modify existing load function to add _loadedTranslations
				const loadLines = lines.slice(loadFunctionStart, loadFunctionEnd + 1);
				const modifiedLoadFunction = modifyLoadFunction(loadLines.join('\n'));
				finalContent += '\n\n' + modifiedLoadFunction;
			} else {
				// Create new load function
				const newLoadFunction = `export const load: ${loadType} = async () => {
	return {
		_loadedTranslations: _getTranslations()
	};
}`;
				finalContent += '\n\n' + newLoadFunction;
			}

			finalContent += '\n' + generatedCode;
			if (afterAutoGenerated.trim()) {
				finalContent += '\n' + afterAutoGenerated.trim();
			}
		} else {
			console.log(`üîç No auto-generated section found, creating new one`);

			// Parse existing content
			const lines = existingContent.split('\n');
			const importLines: string[] = [];
			const codeLines: string[] = [];
			let inLoadFunction = false;
			let braceCount = 0;

			for (let i = 0; i < lines.length; i++) {
				const line = lines[i];

				// Check if this line starts a load function (both with and without type annotation)
				if (
					(line.includes('export const load:') || line.includes('export const load =')) &&
					!inLoadFunction
				) {
					hasLoadFunction = true;
					loadFunctionStart = i;
					inLoadFunction = true;
					braceCount = 0;
				}

				if (inLoadFunction) {
					// Count braces to find the end of the load function
					braceCount += (line.match(/\{/g) || []).length;
					braceCount -= (line.match(/\}/g) || []).length;

					if (braceCount === 0 && line.trim() !== '') {
						loadFunctionEnd = i;
						inLoadFunction = false;
					}
				} else {
					// Check if this is an import statement
					if (line.trim().startsWith('import ')) {
						importLines.push(line);
					} else {
						codeLines.push(line);
					}
				}
			}

			existingImports = importLines;
			existingCode = codeLines.join('\n');

			// Add required imports if they don't exist
			const allImports = [...new Set([...existingImports, ...requiredImports])];

			// Build final content - clean up empty lines
			const cleanImports = allImports.join('\n');
			const cleanExistingCode = existingCode.replace(/\n\s*\n\s*\n/g, '\n\n').trim();

			finalContent = cleanImports;
			if (cleanExistingCode) {
				finalContent += '\n\n' + cleanExistingCode;
			}

			if (hasLoadFunction) {
				// Modify existing load function to add _loadedTranslations
				const loadLines = lines.slice(loadFunctionStart, loadFunctionEnd + 1);
				const modifiedLoadFunction = modifyLoadFunction(loadLines.join('\n'));
				finalContent += '\n\n' + modifiedLoadFunction;
			} else {
				// Create new load function
				const newLoadFunction = `export const load: ${loadType} = async () => {
	return {
		_loadedTranslations: _getTranslations()
	};
}`;
				finalContent += '\n\n' + newLoadFunction;
			}

			finalContent += '\n' + generatedCode;
		}
	} else {
		// Create new file with imports, generated code, and load function
		const newLoadFunction = `export const load: ${loadType} = async () => {
	return {
		_loadedTranslations: _getTranslations()
	};
}`;

		finalContent = requiredImports.join('\n') + '\n\n' + newLoadFunction + generatedCode;
	}

	writeFileSync(serverFilePath, finalContent, 'utf8');
	console.log(
		`‚úÖ ${existsSync(serverFilePath) ? 'Updated' : 'Created'} ${isLayoutFile ? '+layout.server.ts' : '+page.server.ts'} for route ${routePath} with ${keysArray.length} translation keys`
	);
}
