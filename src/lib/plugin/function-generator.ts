import { mkdir, writeFile } from 'fs/promises';
import { dirname, join, resolve } from 'path';
import { generateTypeScriptDeclarations, sanitizeFunctionName } from './helpers.js';

/**
 * Load default translations from the specified path
 */
export async function loadDefaultTranslations(
	defaultPath: string
): Promise<Record<string, string>> {
	const defaultTranslationsPath = resolve(defaultPath);
	const defaultTranslationsModule = await import(defaultTranslationsPath);
	return defaultTranslationsModule.default;
}

/**
 * Generate individual translation function files
 */
export async function generateTranslations(
	defaultPath: string,
	runtimePath: string,
	verbose: boolean = false
): Promise<void> {
	try {
		// Read default translations
		const defaultTranslations = await loadDefaultTranslations(defaultPath);

		// Create runtime directory
		const runtimeDir = dirname(runtimePath);
		await mkdir(runtimeDir, { recursive: true });

		// Generate individual files for each translation function
		const entries = Object.entries(defaultTranslations);

		// Note: utils.ts is now maintained manually in src/lib/helpers/utils.ts
		// and imported from there instead of being auto-generated

		// Generate individual files for each translation function
		for (const [key, value] of entries) {
			const safeFunctionName = sanitizeFunctionName(key);
			const hasPlaceholders = typeof value === 'string' && value.includes('{{');

			let functionCode = '// This file is auto-generated by sveltekit-translations-loader plugin\n';
			functionCode += '// Do not edit manually\n\n';

			if (hasPlaceholders) {
				functionCode += "import { r, getTData } from '$lib/helpers/utils.js';\n\n";
			} else {
				functionCode += "import { getTData } from '$lib/helpers/utils.js';\n\n";
			}

			functionCode += `/**\n * @description ${value}\n */\n`;

			if (hasPlaceholders) {
				// Extract parameter names from the translation string
				const paramRegex = /{{([^}]+)}}/g;
				const params = new Set<string>();
				let match;
				while ((match = paramRegex.exec(value)) !== null) {
					params.add(match[1].trim());
				}
				const paramArray = Array.from(params);

				if (paramArray.length === 1) {
					// Single parameter: accept the value directly
					const paramName = paramArray[0];
					functionCode += `export const ${safeFunctionName} = (${paramName}: string | number): string => {\n`;
					functionCode += `  const data = getTData();\n`;
					functionCode += `  const text = data['${key}'];\n`;
					functionCode += `  return r(text, { ${paramName} });\n`;
					functionCode += `};\n`;
				} else {
					// Multiple parameters: use params object
					functionCode += `export const ${safeFunctionName} = (params?: Record<string, string | number>): string => {\n`;
					functionCode += `  const data = getTData();\n`;
					functionCode += `  const text = data['${key}'];\n`;
					functionCode += `  return r(text, params);\n`;
					functionCode += `};\n`;
				}
			} else {
				functionCode += `export const ${safeFunctionName} = (): string => {\n`;
				functionCode += `  const data = getTData();\n`;
				functionCode += `  return data['${key}'];\n`;
				functionCode += `};\n`;
			}

			const functionPath = join(runtimeDir, `${safeFunctionName}.ts`);
			await writeFile(functionPath, functionCode);
		}

		// Generate index file that re-exports all functions
		let indexCode = '// This file is auto-generated by sveltekit-translations-loader plugin\n';
		indexCode += '// Do not edit manually\n\n';

		// Re-export all individual functions
		entries.forEach(([key]) => {
			const safeFunctionName = sanitizeFunctionName(key);
			indexCode += `export { ${safeFunctionName} } from './${safeFunctionName}.js';\n`;
		});

		const indexPath = join(runtimeDir, 'index.ts');
		await writeFile(indexPath, indexCode);

		// Generate TypeScript declarations
		const dtsContent = generateTypeScriptDeclarations(defaultTranslations);
		const dtsPath = join(runtimeDir, 'index.d.ts');
		await writeFile(dtsPath, dtsContent);

		if (verbose) {
			console.log('✅ Generated individual translation files for tree-shaking');
		}
	} catch (error) {
		if (verbose) {
			console.error('❌ Error generating translations:', error);
		}
	}
}
