import { mkdir, rm } from 'fs/promises';
import { join, resolve } from 'path';
import { forceFlushFileWrites, queueFileWrite, queueFileWrites } from './batch-file-writer.js';
import { generateTypeScriptDeclarations, sanitizeFunctionName } from './helpers.js';

// Constants
const AUTO_GENERATED_HEADER = [
	'// This file is auto-generated by sveltekit-translations-loader plugin',
	'// Do not edit manually',
	''
].join('\n');

const PARAMETER_REGEX = /{{([^}]+)}}/g;

// Types
interface TranslationEntry {
	key: string;
	value: string;
	safeFunctionName: string;
	hasPlaceholders: boolean;
	parameters: string[];
}

interface FunctionGenerationConfig {
	development: boolean;
	runtimeDir: string;
}

interface GeneratedFile {
	path: string;
	content: string;
}

/**
 * Load default translations from the specified path
 */
export async function loadDefaultTranslations(
	defaultPath: string
): Promise<Record<string, string>> {
	const defaultTranslationsPath = resolve(defaultPath);
	const defaultTranslationsModule = await import(defaultTranslationsPath);
	return defaultTranslationsModule.default;
}

/**
 * Extract parameters from translation value
 */
function extractParameters(value: string): string[] {
	const params = new Set<string>();
	let match;

	while ((match = PARAMETER_REGEX.exec(value)) !== null) {
		params.add(match[1].trim());
	}

	return Array.from(params);
}

/**
 * Check if a translation value has placeholders
 */
function hasPlaceholders(value: string): boolean {
	return value.includes('{{');
}

/**
 * Create translation entry with metadata
 */
function createTranslationEntry(key: string, value: string): TranslationEntry {
	return {
		key,
		value,
		safeFunctionName: sanitizeFunctionName(key),
		hasPlaceholders: hasPlaceholders(value),
		parameters: extractParameters(value)
	};
}

/**
 * Get helpers import path based on environment
 */
function getHelpersImportPath(development: boolean): string {
	return development ? '$lib/helpers' : 'sveltekit-translations-loader/helpers';
}

/**
 * Generate function body for parameterized translation
 */
function generateParameterizedFunctionBody(entry: TranslationEntry): string {
	const { safeFunctionName, key, parameters } = entry;

	if (parameters.length === 1) {
		// Single parameter: accept the value directly
		const paramName = parameters[0];
		return `export const ${safeFunctionName} = (${paramName}: string | number): string => {
  const text = getTData()['${key}'];
  return r(text, { ${paramName} });
};`;
	} else {
		// Multiple parameters: use params object
		return `export const ${safeFunctionName} = (params?: Record<string, string | number>): string => {
  const text = getTData()['${key}'];
  return r(text, params);
};`;
	}
}

/**
 * Generate function body for simple translation
 */
function generateSimpleFunctionBody(entry: TranslationEntry): string {
	const { safeFunctionName, key } = entry;

	return `export const ${safeFunctionName} = (): string => {
  return getTData()['${key}'];
};`;
}

/**
 * Generate import statements for translation function
 */
function generateImports(hasPlaceholders: boolean, helpersImport: string): string {
	if (hasPlaceholders) {
		return `import { r, getTData } from '${helpersImport}';\n\n`;
	} else {
		return `import { getTData } from '${helpersImport}';\n\n`;
	}
}

/**
 * Generate individual translation function file content
 */
function generateFunctionFileContent(
	entry: TranslationEntry,
	config: FunctionGenerationConfig
): string {
	const { hasPlaceholders, value } = entry;
	const helpersImport = getHelpersImportPath(config.development);

	let content = AUTO_GENERATED_HEADER;
	content += generateImports(hasPlaceholders, helpersImport);
	content += `/**\n * @description Text: ${value}\n */\n`;

	if (hasPlaceholders) {
		content += generateParameterizedFunctionBody(entry);
	} else {
		content += generateSimpleFunctionBody(entry);
	}

	return content;
}

/**
 * Generate individual translation function files
 */
async function generateIndividualFiles(
	entries: TranslationEntry[],
	config: FunctionGenerationConfig
): Promise<GeneratedFile[]> {
	const files: GeneratedFile[] = [];

	for (const entry of entries) {
		const content = generateFunctionFileContent(entry, config);
		const path = join(config.runtimeDir, `${entry.safeFunctionName}.ts`);

		files.push({ path, content });
	}

	// Queue all file writes for batch processing
	const writes = files.map((file) => ({ path: file.path, content: file.content }));
	queueFileWrites(writes);

	return files;
}

/**
 * Generate index file content
 */
function generateIndexFileContent(entries: TranslationEntry[]): string {
	let content = AUTO_GENERATED_HEADER;

	// Re-export all individual functions
	entries.forEach((entry) => {
		content += `export { ${entry.safeFunctionName} } from './${entry.safeFunctionName}.js';\n`;
	});

	return content;
}

/**
 * Clean up the entire messages directory and recreate it
 */
async function cleanupAndRecreateDirectory(
	runtimeDir: string,
	verbose: boolean = false
): Promise<void> {
	try {
		// Remove the entire directory if it exists
		await rm(runtimeDir, { recursive: true, force: true });

		if (verbose) {
			console.log(`üóëÔ∏è  Wiped ${runtimeDir} directory`);
		}
	} catch (error) {
		if (verbose) {
			console.warn('‚ö†Ô∏è  Failed to cleanup directory:', error);
		}
	}
}

/**
 * Generate all output files
 */
async function generateOutputFiles(
	entries: TranslationEntry[],
	config: FunctionGenerationConfig,
	defaultTranslations: Record<string, string>
): Promise<void> {
	// Generate individual function files
	await generateIndividualFiles(entries, config);

	// Generate index file
	const indexContent = generateIndexFileContent(entries);
	const indexPath = join(config.runtimeDir, 'index.ts');
	queueFileWrite(indexPath, indexContent);

	// Generate TypeScript declarations
	const dtsContent = generateTypeScriptDeclarations(defaultTranslations);
	const dtsPath = join(config.runtimeDir, 'index.d.ts');
	queueFileWrite(dtsPath, dtsContent);

	// Force flush to ensure all files are written
	await forceFlushFileWrites();
}

/**
 * Generate individual translation function files
 */
export async function generateTranslations(
	defaultPath: string,
	runtimePath: string,
	verbose: boolean = false,
	development: boolean = false
): Promise<void> {
	try {
		// Read default translations
		const defaultTranslations = await loadDefaultTranslations(defaultPath);

		// Create runtime directory (runtimePath is already the messages directory)
		await mkdir(runtimePath, { recursive: true });

		// Create translation entries
		const entries = Object.entries(defaultTranslations).map(([key, value]) =>
			createTranslationEntry(key, value)
		);

		// Configuration for file generation
		const config: FunctionGenerationConfig = {
			development,
			runtimeDir: runtimePath
		};

		// Pass verbose flag to cleanup function
		await cleanupAndRecreateDirectory(runtimePath, verbose);

		// Generate all output files
		await generateOutputFiles(entries, config, defaultTranslations);

		if (verbose) {
			console.log('‚úÖ Generated individual translation files for tree-shaking');
		}
	} catch (error) {
		if (verbose) {
			console.error('‚ùå Error generating translations:', error);
		}
	}
}
