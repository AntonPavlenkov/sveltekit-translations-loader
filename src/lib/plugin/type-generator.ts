import { writeFileSync } from 'fs';
import { basename, resolve } from 'path';
import { loadDefaultTranslations } from './function-generator.js';

// Constants
const PARAMETER_REGEX = /{{([^}]+)}}/g;

const TYPE_DECLARATION_HEADER = [
	'// Auto-generated TypeScript declarations for @@i18n',
	'// This file is generated by the sveltekit-translations-loader plugin',
	'// Do not edit manually',
	'',
	"declare module '@i18n' {",
	'\t// Re-export all translation functions',
	'\texport * from {relativePath};',
	'',
	'\t// Namespace for t.hello() syntax',
	'\texport const t: {'
].join('\n');

const TYPE_DECLARATION_FOOTER = [
	'\t};',
	'',
	'\t// Individual function exports',
	'{functionDeclarations}',
	'}'
].join('\n');

const DEFAULT_RUNTIME_PATH = "'$lib/runtime/index.js'";

// Types
interface TranslationEntry {
	key: string;
	value: string;
	functionName: string;
	parameters: string[];
}

/**
 * Convert kebab-case to camelCase for function names
 */
function sanitizeFunctionName(key: string): string {
	return key.replace(/[-_\s]+(.)?/g, (_, char) => (char ? char.toUpperCase() : ''));
}

/**
 * Extract parameter names from translation string
 */
function extractParamsFromTranslation(translation: string): string[] {
	const params = new Set<string>();
	let match;

	while ((match = PARAMETER_REGEX.exec(translation)) !== null) {
		params.add(match[1].trim());
	}

	return Array.from(params);
}

/**
 * Create translation entry with metadata
 */
function createTranslationEntry(key: string, value: string): TranslationEntry {
	return {
		key,
		value,
		functionName: sanitizeFunctionName(key),
		parameters: extractParamsFromTranslation(value)
	};
}

/**
 * Create JSDoc comment for translation
 */
function createJsDocComment(value: string, indentLevel: number = 1): string {
	const indent = '\t'.repeat(indentLevel);
	const commentLines = value.split('\n').map((line) => `${indent} * ${line}`);
	return `${indent}/**\n${commentLines.join('\n')}\n${indent} */`;
}

/**
 * Generate function signature based on parameters
 */
function generateFunctionSignature(
	functionName: string,
	parameters: string[],
	indentLevel: number = 1
): string {
	const indent = '\t'.repeat(indentLevel);

	if (parameters.length === 0) {
		return `${indent}export function ${functionName}(): string;`;
	} else if (parameters.length === 1) {
		// Single parameter: accept the value directly
		const paramName = parameters[0];
		return `${indent}export function ${functionName}(${paramName}: string | number | boolean): string;`;
	} else {
		// Multiple parameters: use params object
		const paramTypes = parameters.map((param) => `${param}: string | number | boolean`).join('; ');
		return `${indent}export function ${functionName}(params: { ${paramTypes} }): string;`;
	}
}

/**
 * Generate namespace entry signature based on parameters
 */
function generateNamespaceSignature(
	functionName: string,
	parameters: string[],
	indentLevel: number = 2
): string {
	const indent = '\t'.repeat(indentLevel);

	if (parameters.length === 0) {
		return `${indent}${functionName}: () => string;`;
	} else if (parameters.length === 1) {
		// Single parameter: accept the value directly
		const paramName = parameters[0];
		return `${indent}${functionName}: (${paramName}: string | number | boolean) => string;`;
	} else {
		// Multiple parameters: use params object
		return `${indent}${functionName}: (params?: Record<string, string | number | boolean>) => string;`;
	}
}

/**
 * Generate function declaration with JSDoc
 */
function generateFunctionDeclaration(entry: TranslationEntry): string {
	const { functionName, value, parameters } = entry;
	const jsDocComment = createJsDocComment(value);
	const functionSignature = generateFunctionSignature(functionName, parameters);

	return `${jsDocComment}\n${functionSignature}`;
}

/**
 * Generate namespace entry with JSDoc
 */
function generateNamespaceEntry(entry: TranslationEntry): string {
	const { functionName, value, parameters } = entry;
	const jsDocComment = createJsDocComment(value, 2);
	const namespaceSignature = generateNamespaceSignature(functionName, parameters);

	return `${jsDocComment}\n${namespaceSignature}`;
}

/**
 * Calculate relative path for runtime imports
 */
function calculateRelativePath(runtimePath?: string): string {
	if (runtimePath) {
		const baseName = basename(runtimePath).replace(/\.js$/, '');
		return `'./${baseName}'`;
	}
	return DEFAULT_RUNTIME_PATH;
}

/**
 * Generate all function declarations
 */
function generateAllFunctionDeclarations(entries: TranslationEntry[]): string {
	return entries.map((entry) => generateFunctionDeclaration(entry)).join('\n');
}

/**
 * Generate all namespace entries
 */
function generateAllNamespaceEntries(entries: TranslationEntry[]): string {
	return entries.map((entry) => generateNamespaceEntry(entry)).join('\n');
}

/**
 * Generate complete TypeScript declarations content
 */
function generateTypeScriptDeclarations(
	translations: Record<string, string>,
	runtimePath?: string
): string {
	const entries = Object.entries(translations).map(([key, value]) =>
		createTranslationEntry(key, value)
	);

	const relativePath = calculateRelativePath(runtimePath);
	const functionDeclarations = generateAllFunctionDeclarations(entries);
	const namespaceEntries = generateAllNamespaceEntries(entries);

	// Build the complete declaration content
	let content = TYPE_DECLARATION_HEADER.replace('{relativePath}', relativePath);
	content += '\n' + namespaceEntries;
	content += '\n' + TYPE_DECLARATION_FOOTER.replace('{functionDeclarations}', functionDeclarations);

	return content;
}

/**
 * Determine output directory and file path
 */
function getOutputPath(runtimePath?: string): { outputDir: string; virtualModulePath: string } {
	const outputDir = runtimePath ? resolve(runtimePath, '..') : resolve('src');
	const virtualModulePath = resolve(outputDir, 'sveltekit-translations-loader.d.ts');

	return { outputDir, virtualModulePath };
}

/**
 * Write type declarations to file
 */
function writeTypeDeclarations(virtualModulePath: string, typeDeclarations: string): void {
	writeFileSync(virtualModulePath, typeDeclarations, 'utf8');
}

/**
 * Generate TypeScript declarations for the virtual module
 */
export async function generateTypeDeclarations(
	defaultPath: string,
	verbose: boolean = false,
	runtimePath?: string
): Promise<void> {
	try {
		// Load default translations to get all available keys
		const defaultTranslations = await loadDefaultTranslations(defaultPath);

		// Generate TypeScript declarations
		const typeDeclarations = generateTypeScriptDeclarations(defaultTranslations, runtimePath);

		// Determine the output path
		const { virtualModulePath } = getOutputPath(runtimePath);

		// Write the type declarations
		writeTypeDeclarations(virtualModulePath, typeDeclarations);

		if (verbose) {
			console.log('✅ Generated TypeScript declarations for @i18n');
		}
	} catch (error) {
		if (verbose) {
			console.error('❌ Failed to generate TypeScript declarations:', error);
		}
	}
}
