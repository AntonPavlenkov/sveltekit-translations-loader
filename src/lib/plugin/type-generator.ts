import { writeFileSync } from 'fs';
import { resolve } from 'path';
import { loadDefaultTranslations } from './function-generator.js';

/**
 * Generate TypeScript declarations for the virtual module
 */
export async function generateTypeDeclarations(defaultPath: string): Promise<void> {
	try {
		// Load default translations to get all available keys
		const defaultTranslations = await loadDefaultTranslations(defaultPath);

		// Generate TypeScript declarations
		const typeDeclarations = generateTypeScriptDeclarations(defaultTranslations);

		// Write to the src directory where it will be included in the TypeScript compilation
		const virtualModulePath = resolve('src', 'sveltekit-translations-loader.d.ts');

		// Write the type declarations
		writeFileSync(virtualModulePath, typeDeclarations, 'utf8');

		console.log('✅ Generated TypeScript declarations for @sveltekit-translations-loader');
	} catch (error) {
		console.error('❌ Failed to generate TypeScript declarations:', error);
	}
}

/**
 * Generate TypeScript declarations content
 */
function generateTypeScriptDeclarations(translations: Record<string, string>): string {
	const functionDeclarations = Object.entries(translations)
		.map(([key, value]) => {
			const functionName = key.replace(/[-_\s]+(.)?/g, (_, char) =>
				char ? char.toUpperCase() : ''
			);

			// Extract parameters from the translation string
			const params = extractParamsFromTranslation(value);

			// Create JSDoc comment with the actual translation text
			const jsDocComment = `\t/**\n\t * ${value.replace(/\n/g, '\n\t * ')}\n\t */`;

			if (params.length === 0) {
				return `${jsDocComment}\n\texport function ${functionName}(): string;`;
			} else if (params.length === 1) {
				// Single parameter: accept the value directly
				const paramName = params[0];
				return `${jsDocComment}\n\texport function ${functionName}(${paramName}: string | number | boolean): string;`;
			} else {
				// Multiple parameters: use params object
				const paramTypes = params.map((param) => `${param}: string | number | boolean`).join('; ');
				return `${jsDocComment}\n\texport function ${functionName}(params: { ${paramTypes} }): string;`;
			}
		})
		.join('\n');

	const namespaceEntries = Object.entries(translations)
		.map(([key, value]) => {
			const functionName = key.replace(/[-_\s]+(.)?/g, (_, char) =>
				char ? char.toUpperCase() : ''
			);
			// Create JSDoc comment for namespace entries
			const jsDocComment = `\t\t/**\n\t\t * ${value.replace(/\n/g, '\n\t\t * ')}\n\t\t */`;

			// Extract parameters to determine the correct signature
			const params = extractParamsFromTranslation(value);

			if (params.length === 0) {
				return `${jsDocComment}\n\t\t${functionName}: () => string;`;
			} else if (params.length === 1) {
				// Single parameter: accept the value directly
				const paramName = params[0];
				return `${jsDocComment}\n\t\t${functionName}: (${paramName}: string | number | boolean) => string;`;
			} else {
				// Multiple parameters: use params object
				return `${jsDocComment}\n\t\t${functionName}: (params?: Record<string, string | number | boolean>) => string;`;
			}
		})
		.join('\n');

	return `// Auto-generated TypeScript declarations for @sveltekit-translations-loader
// This file is generated by the sveltekit-translations-loader plugin
// Do not edit manually

declare module '@sveltekit-translations-loader' {
	// Re-export all translation functions
	export * from '../../lib/translations/messages/index.js';
	
	// Namespace for t.hello() syntax
	export const t: {
${namespaceEntries}
	};
	
	// Individual function exports
${functionDeclarations}
}
`;
}

/**
 * Extract parameter names from translation string
 */
function extractParamsFromTranslation(translation: string): string[] {
	const paramRegex = /{{([^}]+)}}/g;
	const params = new Set<string>();
	let match;

	while ((match = paramRegex.exec(translation)) !== null) {
		params.add(match[1].trim());
	}

	return Array.from(params);
}
