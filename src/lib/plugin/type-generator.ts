import { writeFileSync } from 'fs';
import { basename, resolve } from 'path';
import { loadDefaultTranslations } from './function-generator.js';

/**
 * Generate TypeScript declarations for the virtual module
 */
export async function generateTypeDeclarations(
	defaultPath: string,
	verbose: boolean = false,
	runtimePath?: string
): Promise<void> {
	try {
		// Load default translations to get all available keys
		const defaultTranslations = await loadDefaultTranslations(defaultPath);

		// Generate TypeScript declarations
		const typeDeclarations = generateTypeScriptDeclarations(defaultTranslations, runtimePath);

		// Determine the output path based on runtimePath or default to src directory
		const outputDir = runtimePath ? resolve(runtimePath, '..') : resolve('src');
		const virtualModulePath = resolve(outputDir, 'sveltekit-translations-loader.d.ts');

		// Write the type declarations
		writeFileSync(virtualModulePath, typeDeclarations, 'utf8');

		if (verbose) {
			console.log('✅ Generated TypeScript declarations for @i18n');
		}
	} catch (error) {
		if (verbose) {
			console.error('❌ Failed to generate TypeScript declarations:', error);
		}
	}
}

/**
 * Generate TypeScript declarations content
 */
function generateTypeScriptDeclarations(
	translations: Record<string, string>,
	runtimePath?: string
): string {
	const functionDeclarations = Object.entries(translations)
		.map(([key, value]) => {
			const functionName = key.replace(/[-_\s]+(.)?/g, (_, char) =>
				char ? char.toUpperCase() : ''
			);

			// Extract parameters from the translation string
			const params = extractParamsFromTranslation(value);

			// Create JSDoc comment with the actual translation text
			const jsDocComment = `\t/**\n\t * ${value.replace(/\n/g, '\n\t * ')}\n\t */`;

			if (params.length === 0) {
				return `${jsDocComment}\n\texport function ${functionName}(): string;`;
			} else if (params.length === 1) {
				// Single parameter: accept the value directly
				const paramName = params[0];
				return `${jsDocComment}\n\texport function ${functionName}(${paramName}: string | number | boolean): string;`;
			} else {
				// Multiple parameters: use params object
				const paramTypes = params.map((param) => `${param}: string | number | boolean`).join('; ');
				return `${jsDocComment}\n\texport function ${functionName}(params: { ${paramTypes} }): string;`;
			}
		})
		.join('\n');

	const namespaceEntries = Object.entries(translations)
		.map(([key, value]) => {
			const functionName = key.replace(/[-_\s]+(.)?/g, (_, char) =>
				char ? char.toUpperCase() : ''
			);
			// Create JSDoc comment for namespace entries
			const jsDocComment = `\t\t/**\n\t\t * ${value.replace(/\n/g, '\n\t\t * ')}\n\t\t */`;

			// Extract parameters to determine the correct signature
			const params = extractParamsFromTranslation(value);

			if (params.length === 0) {
				return `${jsDocComment}\n\t\t${functionName}: () => string;`;
			} else if (params.length === 1) {
				// Single parameter: accept the value directly
				const paramName = params[0];
				return `${jsDocComment}\n\t\t${functionName}: (${paramName}: string | number | boolean) => string;`;
			} else {
				// Multiple parameters: use params object
				return `${jsDocComment}\n\t\t${functionName}: (params?: Record<string, string | number | boolean>) => string;`;
			}
		})
		.join('\n');

	// Calculate relative path from the generated type declarations file to the runtime path
	const relativePath = runtimePath
		? `'./${basename(runtimePath).replace(/\.js$/, '')}'`
		: "'$lib/runtime/index.js'";

	return `// Auto-generated TypeScript declarations for @@i18n
// This file is generated by the sveltekit-translations-loader plugin
// Do not edit manually

declare module '@i18n' {
	// Re-export all translation functions
	export * from ${relativePath};
	
	// Namespace for t.hello() syntax
	export const t: {
${namespaceEntries}
	};
	
	// Individual function exports
${functionDeclarations}
}
`;
}

/**
 * Extract parameter names from translation string
 */
function extractParamsFromTranslation(translation: string): string[] {
	const paramRegex = /{{([^}]+)}}/g;
	const params = new Set<string>();
	let match;

	while ((match = paramRegex.exec(translation)) !== null) {
		params.add(match[1].trim());
	}

	return Array.from(params);
}
